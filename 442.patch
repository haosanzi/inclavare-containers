From 91063cf81de9693d618199735bd662eb85d488f6 Mon Sep 17 00:00:00 2001
From: Jia Zhang <zhang.jia@linux.alibaba.com>
Date: Sat, 19 Dec 2020 06:54:43 +0000
Subject: [PATCH] rune/skeleton: allow to explicitely set attrs_mask and
 xfrm_mask in sigstruct

Add the following options:
- --attrs-mask: set attributes mask to enforce
- --xfrm-mask: set xfrm mask to enforce

Additionally, remove xfrm and attributes from metadata area. Actually
sig.attrs and sig.xfrm can stand for secs.attrs and secs.xfrm.

Signed-off-by: Shirong Hao <shirong@linux.alibaba.com>
Signed-off-by: Jia Zhang <zhang.jia@linux.alibaba.com>
---
 .../internal/runtime/pal/skeleton/README.md   |  10 +-
 .../internal/runtime/pal/skeleton/arch.h      |   9 +-
 .../internal/runtime/pal/skeleton/defines.h   |   6 +
 .../internal/runtime/pal/skeleton/encl.c      |   2 -
 .../runtime/pal/skeleton/liberpal-skeleton.c  | 127 ++++++++----
 .../internal/runtime/pal/skeleton/sgxsign.c   | 186 +++++++++++++-----
 6 files changed, 244 insertions(+), 96 deletions(-)

diff --git a/rune/libenclave/internal/runtime/pal/skeleton/README.md b/rune/libenclave/internal/runtime/pal/skeleton/README.md
index 50507ca1..58b1e985 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/README.md
+++ b/rune/libenclave/internal/runtime/pal/skeleton/README.md
@@ -225,9 +225,13 @@ The options provided by `sgxsign` tool are as followed:
 | Options                             | Function                                                                                               |
 | ----------------------------------- | -------------------------------------------------------------------------------------------------------|
 | -p, --product                       | Generate production enclave. Debug enclave is generated by default.                                    |
-| -s, --mmap-size value               | Launch an enclave with memory size equals to value(bytes).                                             |
-| -a, --attrs value                   | Launch an enclave with attributes equals to value(hex).                                                |
-| -x, --xfrm value                    | Launch an enclave with xfrm equals to value(hex).                                                      |
+| -s, --mmap-size value               | Launch an enclave with memory size equals to value (in-byte).                                          |
+| -a, --attrs value                   | Launch an enclave with attributes equals to value (in hex).                                            |
+| -A, --attrs-mask value              | Enforce the attributes value (in hex) specified by --attrs.
+                                   |
+| -x, --xfrm value                    | Launch an enclave with xfrm equals to value (in hex).                                                  |
+| -X, --xfrm-mask value               | Enforce the xfrm value (in hex) specified by --xfrm.
+                                   |
 | -n, --null\_dereference\_protection | Enable [Enclave NULL dereference protection](#enclave-null-dereference-protection). Disable by default.|
 | -m, --mman\_min\_addr value         | Launch an enclave with mman\_min\_addr equals to value(hex).                                           |
 
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/arch.h b/rune/libenclave/internal/runtime/pal/skeleton/arch.h
index caf27e86..9cb8d005 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/arch.h
+++ b/rune/libenclave/internal/runtime/pal/skeleton/arch.h
@@ -90,6 +90,7 @@ enum sgx_attribute {
 
 #define SGX_ATTR_RESERVED_MASK	(BIT_ULL(3) | BIT_ULL(6) | GENMASK_ULL(63, 8))
 #define SGX_ATTR_ALLOWED_MASK	(SGX_ATTR_DEBUG | SGX_ATTR_MODE64BIT | \
+				 SGX_ATTR_PROVISIONKEY | SGX_ATTR_EINITTOKENKEY | \
 				 SGX_ATTR_KSS)
 
 /**
@@ -428,14 +429,6 @@ struct sgx_report {
 } __packed __aligned(512);
 static_assert(sizeof(struct sgx_report) == 512, "incorrect size of sgx_report");
 
-struct metadata {
-	uint64_t max_mmap_size;
-	uint64_t attributes;
-	uint64_t xfrm;
-	bool null_dereference_protection;
-	uint64_t mmap_min_addr;
-} __packed;
-
 /* *INDENT-OFF* */
 #endif   /* _ASM_X86_SGX_ARCH_H */
 /* *INDENT-ON* */
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/defines.h b/rune/libenclave/internal/runtime/pal/skeleton/defines.h
index 4ec09c75..a89d2887 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/defines.h
+++ b/rune/libenclave/internal/runtime/pal/skeleton/defines.h
@@ -14,6 +14,12 @@
 #define __packed __attribute__((packed))
 #define static_assert _Static_assert
 
+struct metadata {
+	uint64_t max_mmap_size;
+	bool null_dereference_protection;
+	uint64_t mmap_min_addr;
+} __packed;
+
 /* *INDENT-OFF* */
 int get_mmap_min_addr(uint64_t *addr);
 /* *INDENT-ON* */
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/encl.c b/rune/libenclave/internal/runtime/pal/skeleton/encl.c
index 6ae9d486..1395c97f 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/encl.c
+++ b/rune/libenclave/internal/runtime/pal/skeleton/encl.c
@@ -8,8 +8,6 @@
 
 struct metadata m __attribute__((section(".metadata"))) = {
 	.max_mmap_size = 0,
-	.attributes = 0,
-	.xfrm = 0,
 	.null_dereference_protection = false,
 	.mmap_min_addr = 0
 };
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/liberpal-skeleton.c b/rune/libenclave/internal/runtime/pal/skeleton/liberpal-skeleton.c
index 5ab48bdb..a906b436 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/liberpal-skeleton.c
+++ b/rune/libenclave/internal/runtime/pal/skeleton/liberpal-skeleton.c
@@ -35,7 +35,6 @@ bool initialized = false;
 static int exit_code;
 static char *sgx_dev_path;
 static bool no_sgx_flc = false;
-static bool enclave_debug = true;
 static int wait_timeout;
 bool debugging = false;
 bool is_oot_driver;
@@ -188,50 +187,99 @@ static int create_enclave_range(int dev_fd, uint64_t mmap_size,
 	return 0;
 }
 
-static bool encl_create(int dev_fd, unsigned long bin_size,
-			struct sgx_secs *secs, struct enclave_info *encl_info,
-			struct metadata *meta_data,
-			struct sgx_sigstruct *sigstruct)
+/* Sanity check attributes to prevent possible tampering */
+static bool check_sgx_attributes(const uint64_t req_attrs,
+				 const uint64_t req_attrs_mask)
 {
-	struct sgx_enclave_create ioc;
-	uint64_t xfrm;
+	/* skeleton doesn't support 32-bit mode */
+	uint64_t enforced_pattern = SGX_ATTR_MODE64BIT;
 
-	memset(secs, 0, sizeof(*secs));
-	secs->attributes = SGX_ATTR_MODE64BIT;
-	if (enclave_debug)
-		secs->attributes |= SGX_ATTR_DEBUG;
-	/* Check attributes to prevent possible tampering of metadata area */
-	if ((meta_data->attributes & sigstruct->body.attributes) !=
-	    sigstruct->body.attributes) {
-		fprintf(stderr, "Invalid attributes value.\n");
+	if (req_attrs & ~SGX_ATTR_ALLOWED_MASK) {
+		fprintf(stderr,
+			"Invalid attributes value. The unsupported attributes %#lx are set.\n",
+			req_attrs & ~SGX_ATTR_ALLOWED_MASK);
+		return false;
+	}
+
+	if ((req_attrs & enforced_pattern) != enforced_pattern) {
+		fprintf(stderr,
+			"Invalid attributes value. The bits %#lx must be set.\n",
+			enforced_pattern & ~req_attrs);
 		return false;
 	}
-	secs->attributes = meta_data->attributes & secs->attributes;
-	/* Check the attributes in signature structure restrictions */
-	if ((sigstruct->body.attributes & sigstruct->body.attributes_mask) !=
-	    (secs->attributes & sigstruct->body.attributes_mask)) {
+
+	if ((req_attrs_mask & enforced_pattern) != enforced_pattern) {
+		fprintf(stderr,
+			"Invalid attributes mask value. The bits %#lx must be set.\n",
+			enforced_pattern & ~req_attrs_mask);
+		return false;
+	}
+
+	return true;
+}
+
+static bool check_sgx_xfrm(uint64_t probed_xfrm, uint64_t req_xfrm,
+			   uint64_t req_xfrm_mask)
+{
+	uint64_t enforced_pattern = SGX_XFRM_LEGACY;
+
+	if ((req_xfrm & enforced_pattern) != enforced_pattern) {
 		fprintf(stderr,
-			"secs attributes does NOT match signature attributes.\n");
+			"Invalid xfrm value. The bits %#lx must be set.\n",
+			enforced_pattern & ~req_xfrm);
 		return false;
 	}
 
-	get_sgx_xfrm_by_cpuid(&xfrm);
-	secs->xfrm = xfrm;
-	/* Check whether the xfrm features in metadata area are available */
-	if ((secs->xfrm & meta_data->xfrm) != meta_data->xfrm) {
+	if ((req_xfrm_mask & enforced_pattern) != enforced_pattern) {
 		fprintf(stderr,
-			"Invalid xfrm value. Unavailable bits are %#lx.\n",
-			meta_data->xfrm & ~(secs->xfrm & meta_data->xfrm));
+			"Invalid xfrm mask value. The bits %#lx must be set.\n",
+			enforced_pattern & ~req_xfrm_mask);
 		return false;
 	}
-	secs->xfrm = meta_data->xfrm & secs->xfrm;
-	/* Check the xfrm in signature structure restrictions */
-	if ((sigstruct->body.xfrm & sigstruct->body.xfrm_mask) !=
-	    (secs->xfrm & sigstruct->body.xfrm_mask)) {
-		fprintf(stderr, "secs xfrm does NOT match signature xfrm.\n");
+
+	/* Check whether the requesting xfrm is supported */
+	if ((req_xfrm & req_xfrm_mask) & ~probed_xfrm) {
+		fprintf(stderr, "Unsupported xfrm bits %#lx.\n",
+			(req_xfrm & req_xfrm_mask) & ~probed_xfrm);
 		return false;
 	}
 
+	return true;
+}
+
+static bool encl_create(int dev_fd, unsigned long bin_size,
+			struct sgx_secs *secs, struct enclave_info *encl_info,
+			struct metadata *meta_data,
+			struct sgx_sigstruct *sigstruct)
+{
+	if (debugging)
+		fprintf(stdout, "sig.attrs %#lx, sig.attrs_mask %#lx\n",
+			sigstruct->body.attributes,
+			sigstruct->body.attributes_mask);
+
+	// *INDENT-OFF*
+	if (!check_sgx_attributes(sigstruct->body.attributes,
+				  sigstruct->body.attributes_mask))
+		return false;
+	// *INDENT-ON*
+	secs->attributes = sigstruct->body.attributes;
+
+	uint64_t probed_xfrm;
+	get_sgx_xfrm_by_cpuid(&probed_xfrm);
+
+	if (debugging)
+		fprintf(stdout,
+			"probed xfrm %#lx, sig.xfrm %#lx, sig.xfrm_mask %#lx\n",
+			probed_xfrm, sigstruct->body.xfrm,
+			sigstruct->body.xfrm_mask);
+
+	// *INDENT-OFF*
+	if (!check_sgx_xfrm(probed_xfrm, sigstruct->body.xfrm,
+			    sigstruct->body.xfrm_mask))
+		return false;
+	// *INDENT-ON*
+	secs->xfrm = sigstruct->body.xfrm;
+
 	secs->miscselect = get_sgx_miscselect_by_cpuid();
 	secs->ssa_frame_size =
 		sgx_calc_ssaframesize(secs->miscselect, secs->xfrm);
@@ -269,6 +317,8 @@ static bool encl_create(int dev_fd, unsigned long bin_size,
 
 	secs->base = encl_info->encl_base;
 	secs->size = encl_info->encl_size;
+
+	struct sgx_enclave_create ioc;
 	ioc.src = (unsigned long) secs;
 	int rc = ioctl(dev_fd, SGX_IOC_ENCLAVE_CREATE, &ioc);
 	if (rc) {
@@ -363,13 +413,16 @@ static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 		return false;
 	}
 
-	if (!(sigstruct->body.attributes & SGX_ATTR_DEBUG))
-		enclave_debug = false;
+	memset(secs, 0, sizeof(*secs));
 
-	/* *INDENT-OFF* */
-	if (!encl_create(dev_fd, bin_size, secs, encl_info, &meta_data, sigstruct))
-		goto out_dev_fd;
-	/* *INDENT-ON* */
+	/* Work around buggy indent */
+	{
+		// *INDENT-OFF*
+		if (!encl_create(dev_fd, bin_size, secs, encl_info, &meta_data,
+				 sigstruct))
+			goto out_dev_fd;
+		// *INDENT-ON*
+	}
 
 	uint64_t *ssa_frame = valloc(PAGE_SIZE * secs->ssa_frame_size);
 	if (ssa_frame == NULL) {
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c b/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
index 3016a84a..5da57552 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
+++ b/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
@@ -23,6 +23,10 @@ struct sgx_sigstruct_payload {
 	struct sgx_sigstruct_body body;
 };
 
+uint64_t req_xfrm, req_xfrm_mask;
+uint64_t req_attrs, req_attrs_mask;
+bool enclave_debug = true;
+
 static bool check_crypto_errors(void)
 {
 	int err;
@@ -309,11 +313,15 @@ static bool measure_encl(const char *path, uint8_t *mrenclave,
 			"when vm.mmap_min_addr is not configured of 0 in OOT driver.\n");
 		return false;
 	}
-	uint64_t encl_offset = calc_enclave_offset(meta_data->mmap_min_addr,
-						   meta_data->
-						   null_dereference_protection);
-	uint64_t encl_size = pow2(encl_offset + mmap_size);
 
+	uint64_t encl_offset;
+	{
+		// *INDENT-OFF*
+		encl_offset = calc_enclave_offset(meta_data->mmap_min_addr,
+						  meta_data->null_dereference_protection);
+		// *INDENT-ON*
+	}
+	uint64_t encl_size = pow2(encl_offset + mmap_size);
 	void *bin = mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE,
 			 fileno(file), 0);
 	if (bin == MAP_FAILED) {
@@ -507,6 +515,120 @@ static bool save_sigstruct(const struct sgx_sigstruct *sigstruct,
 	return true;
 }
 
+// *INDENT-OFF*
+static int calc_sgx_attributes(uint64_t *ret_attrs, uint64_t *ret_attrs_mask)
+{
+	/* skeleton doesn't support 32-bit mode */
+	uint64_t enforced_pattern = SGX_ATTR_MODE64BIT;
+
+#ifdef CONFIG_EINITTOKENKEY
+	enforced_pattern |= SGX_ATTR_EINITTOKENKEY;
+#endif
+	if (enclave_debug)
+		enforced_pattern |= SGX_ATTR_DEBUG;
+
+	if (req_attrs) {
+		if (req_attrs & ~SGX_ATTR_ALLOWED_MASK) {
+			fprintf(stderr,
+				"Invalid option --attrs. The unsupported attributes %#lx are set.\n",
+				req_attrs & ~SGX_ATTR_ALLOWED_MASK);
+			return -1;
+		}
+
+		if ((req_attrs & enforced_pattern) != enforced_pattern) {
+			fprintf(stderr,
+				"Invalid option --attrs. The bitmap %#lx must be set.\n",
+				enforced_pattern & ~req_attrs);
+			return -1;
+		}
+
+		if (!req_attrs_mask)
+			req_attrs_mask = req_attrs;
+	}
+
+	if (req_attrs_mask) {
+		if ((req_attrs_mask & enforced_pattern) != enforced_pattern) {
+			fprintf(stderr,
+				"Invalid option --attrs-mask. The bitmap %#lx must be set.\n",
+				enforced_pattern & ~req_attrs_mask);
+			return -1;
+		}
+
+		if (!req_attrs)
+			req_attrs = req_attrs_mask;
+	}
+
+	if (req_attrs) {
+		if (enclave_debug &&
+		    !(req_attrs & req_attrs_mask & SGX_ATTR_DEBUG)) {
+			fprintf(stderr,
+				"--attrs conflicts with debug enclave.\n");
+			return -1;
+		}
+
+		if (!enclave_debug &&
+		    (req_attrs & req_attrs_mask & SGX_ATTR_DEBUG)) {
+			fprintf(stderr,
+				"--attrs conflicts with product enclave.\n");
+			return -1;
+		}
+
+		*ret_attrs = req_attrs;
+		*ret_attrs_mask = req_attrs_mask;
+
+		return 0;
+	}
+
+	*ret_attrs = enforced_pattern;
+	*ret_attrs_mask = enforced_pattern;
+
+	return 0;
+}
+
+static int calc_sgx_xfrm(uint64_t *ret_xfrm, uint64_t *ret_xfrm_mask)
+{
+	uint64_t calc_xfrm, calc_xfrm_mask;
+
+	get_sgx_xfrm_by_cpuid(&calc_xfrm);
+	calc_xfrm_mask = calc_xfrm;
+
+	const uint64_t enforced_pattern = SGX_XFRM_LEGACY;
+
+	if (req_xfrm) {
+		if ((req_xfrm & enforced_pattern) != enforced_pattern) {
+			fprintf(stderr,
+				"Invalid option --xfrm. The minimum bits %#lx are not set.\n",
+				enforced_pattern & ~req_xfrm);
+			return -1;
+		}
+
+		if (!req_xfrm_mask)
+			req_xfrm_mask = req_xfrm;
+
+		calc_xfrm = req_xfrm;
+	}
+
+	if (req_xfrm_mask) {
+		if ((req_xfrm_mask & enforced_pattern) != enforced_pattern) {
+			fprintf(stderr,
+				"Invalid option --xfrm-mask. The minimum bits %#lx are not set.\n",
+				enforced_pattern & ~req_xfrm_mask);
+			return -1;
+		}
+
+		if (!req_xfrm)
+			calc_xfrm = req_xfrm = req_xfrm_mask;
+
+		calc_xfrm_mask = req_xfrm_mask;
+	}
+
+	*ret_xfrm = calc_xfrm;
+	*ret_xfrm_mask = calc_xfrm_mask;
+
+	return 0;
+}
+// *INDENT-ON*
+
 int main(int argc, char **argv)
 {
 	uint64_t mmap_min_addr;
@@ -518,12 +640,10 @@ int main(int argc, char **argv)
 
 	uint64_t header1[2] = { 0x000000E100000006, 0x0000000000010000 };
 	uint64_t header2[2] = { 0x0000006000000101, 0x0000000100000060 };
-	uint64_t xfrm;
 	struct sgx_sigstruct ss;
 	const char *program;
 	int opt;
 	RSA *sign_key;
-	bool enclave_debug = true;
 	struct metadata meta_data;
 	char *const short_options = "ps:x:a:nm:";
 	struct option long_options[] = {
@@ -531,6 +651,8 @@ int main(int argc, char **argv)
 		{"mmap-size", required_argument, NULL, 's'},
 		{"xfrm", required_argument, NULL, 'x'},
 		{"attrs", required_argument, NULL, 'a'},
+		{"xfrm-mask", required_argument, NULL, 'X'},
+		{"attrs-mask", required_argument, NULL, 'A'},
 		{"null_dereference_protection", no_argument, NULL, 'n'},
 		{"mmap_min_addr", required_argument, NULL, 'm'},
 		{0, 0, 0, 0}
@@ -551,10 +673,16 @@ int main(int argc, char **argv)
 			meta_data.max_mmap_size = atoi(optarg);
 			break;
 		case 'x':
-			meta_data.xfrm = strtol(optarg, NULL, 16);
+			req_xfrm = strtol(optarg, NULL, 16);
+			break;
+		case 'X':
+			req_xfrm_mask = strtol(optarg, NULL, 16);
 			break;
 		case 'a':
-			meta_data.attributes = strtol(optarg, NULL, 16);
+			req_attrs = strtol(optarg, NULL, 16);
+			break;
+		case 'A':
+			req_attrs_mask = strtol(optarg, NULL, 16);
 			break;
 		case 'n':
 			meta_data.null_dereference_protection = true;
@@ -582,46 +710,12 @@ int main(int argc, char **argv)
 	ss.header.header2[1] = header2[1];
 	ss.exponent = 3;
 
-#ifndef CONFIG_EINITTOKENKEY
-	ss.body.attributes = SGX_ATTR_MODE64BIT;
-#else
-	ss.body.attributes = SGX_ATTR_MODE64BIT | SGX_ATTR_EINITTOKENKEY;
-#endif
-	if (enclave_debug)
-		ss.body.attributes |= SGX_ATTR_DEBUG;
-	if (meta_data.attributes) {
-		/* The minimum set of attributes must be set */
-		if ((meta_data.attributes & ss.body.attributes) !=
-		    ss.body.attributes) {
-			fprintf(stderr,
-				"Invalid attributes value. The minimum set of attributes %#lx must be set.\n",
-				ss.body.attributes);
-			return -1;
-		}
-
-		ss.body.attributes = meta_data.attributes;
-	} else {
-		meta_data.attributes = ss.body.attributes;
-	}
-
-	get_sgx_xfrm_by_cpuid(&xfrm);
-	ss.body.xfrm = xfrm;
-	if (meta_data.xfrm) {
-		/* The minimum set of xfrm must be set */
-		if ((meta_data.xfrm & SGX_XFRM_LEGACY) != SGX_XFRM_LEGACY) {
-			fprintf(stderr,
-				"Invalid xfrm value. The minimum set of xfrm %#llx must be set.\n",
-				SGX_XFRM_LEGACY);
-			return -1;
-		}
+	if (calc_sgx_attributes(&ss.body.attributes, &ss.body.attributes_mask))
+		return -1;
 
-		ss.body.xfrm = meta_data.xfrm;
-	} else {
-		meta_data.xfrm = ss.body.xfrm;
-	}
+	if (calc_sgx_xfrm(&ss.body.xfrm, &ss.body.xfrm_mask))
+		return -1;
 
-	ss.body.attributes_mask = ss.body.attributes;
-	ss.body.xfrm_mask = ss.body.xfrm;
 	ss.body.miscselect = get_sgx_miscselect_by_cpuid();
 
 	/* sanity check only */
