Date: Wed, 9 Dec 2020 09:20:41 +0000
Subject: [PATCH] rune/libenclave/skeleton: add xfrm metadata

Signed-off-by: Shirong Hao <shirong@linux.alibaba.com>

diff --git a/rune/libenclave/internal/runtime/pal/skeleton/Makefile b/rune/libenclave/internal/runtime/pal/skeleton/Makefile
index 2733414..754fce3 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/Makefile
+++ b/rune/libenclave/internal/runtime/pal/skeleton/Makefile
@@ -73,7 +73,8 @@ else
 endif
 
 $(OUTPUT)/encl.ss: $(OUTPUT)/encl.bin $(OUTPUT)/signing_key.pem
-	$(OUTPUT)/sgxsign $(PRODUCT_OPT) signing_key.pem $(OUTPUT)/encl.bin $(OUTPUT)/encl.ss
+	$(OUTPUT)/sgxsign -s 40960000 $(PRODUCT_OPT) signing_key.pem $(OUTPUT)/encl.bin $(OUTPUT)/encl.ss
+
 
 $(OUTPUT)/sgxsign: sgxsign.c sgxutils.c
 	$(CC) -I../include -o $@ $^ -lcrypto
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/arch.h b/rune/libenclave/internal/runtime/pal/skeleton/arch.h
index fa22ba8..00d2b81 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/arch.h
+++ b/rune/libenclave/internal/runtime/pal/skeleton/arch.h
@@ -430,7 +430,10 @@ static_assert(sizeof(struct sgx_report) == 512, "incorrect size of sgx_report");
 
 struct metadata {
 	uint64_t max_mmap_size;
-};
+	bool null_dereference_protection;
+	uint64_t attributes;
+	uint64_t xfrm;
+} __packed;
 
 /* *INDENT-OFF* */
 #endif   /* _ASM_X86_SGX_ARCH_H */
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/encl.c b/rune/libenclave/internal/runtime/pal/skeleton/encl.c
index 83b3565..4054e23 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/encl.c
+++ b/rune/libenclave/internal/runtime/pal/skeleton/encl.c
@@ -7,7 +7,10 @@
 #include "sgx_call.h"
-	.max_mmap_size = 0
+	.max_mmap_size = 0,
+	.null_dereference_protection = false,
+	.attributes = 0,
+	.xfrm = 0
 };
 
 static void *memcpy(void *dest, const void *src, size_t n)
@@ -30,13 +30,13 @@
 
 struct sgx_secs secs;
 static pal_stdio_fds pal_stdio = { -1, -1, -1 };
+
 bool initialized = false;
 static int exit_code;
 static char *sgx_dev_path;
 static bool no_sgx_flc = false;
 static bool enclave_debug = true;
 static int wait_timeout;
-uint64_t max_mmap_size = 0;
 bool debugging = false;
 bool is_oot_driver;
 bool backend_kvm = false;
@@ -165,7 +165,7 @@ static int create_enclave_range(int dev_fd, uint64_t mmap_size,
 
 static bool encl_create(int dev_fd, unsigned long bin_size,
 			struct sgx_secs *secs, struct enclave_info *encl_info,
-			uint64_t max_mmap_size)
+			struct metadata *meta_data)
 {
 	struct sgx_enclave_create ioc;
 	uint64_t xfrm;
@@ -175,23 +175,31 @@ static bool encl_create(int dev_fd, unsigned long bin_size,
 	if (enclave_debug)
 		secs->attributes |= SGX_ATTR_DEBUG;
 
+	/* The value of xfrm is caculated by cpuid. If the user predefined the value in enclave images, then using the predefined value. */
 	get_sgx_xfrm_by_cpuid(&xfrm);
 	secs->xfrm = xfrm;
+	if (meta_data->xfrm)
+		secs->xfrm = meta_data->xfrm;
+	if (xfrm != meta_data->xfrm) {
+		printf("The predefined xfrm value %ld is wrong. Please change xfrm value to %ld\n", meta_data->xfrm, xfrm);
+		//return false;
+	}
+	printf("***** liberskelton: secs->xfrm is %ld\n", secs->xfrm);
 
 	secs->miscselect = get_sgx_miscselect_by_cpuid();
 	secs->ssa_frame_size =
 		sgx_calc_ssaframesize(secs->miscselect, secs->xfrm);
 
 	uint64_t mmap_size = bin_size + PAGE_SIZE * secs->ssa_frame_size;
-	if (max_mmap_size) {
-		if (max_mmap_size < mmap_size) {
+	if (meta_data->max_mmap_size) {
+		if (meta_data->max_mmap_size < mmap_size) {
 			fprintf(stderr,
 				"Invalid enclave mmap size %lu, "
 				"set enclave mmap size larger than %lu.\n",
-				max_mmap_size, mmap_size);
+				meta_data->max_mmap_size, mmap_size);
 			return false;
-		mmap_size = max_mmap_size;
+		mmap_size = meta_data->max_mmap_size;
 	}
 
 	if (mmap_size % PAGE_SIZE)
@@ -292,14 +300,18 @@ static bool encl_add_pages(int dev_fd, uint64_t addr, void *data,
 static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 		       struct sgx_sigstruct *sigstruct,
 		       struct sgx_einittoken *token,
-		       struct enclave_info *encl_info, uint64_t max_mmap_size)
+		       struct enclave_info *encl_info)
 {
 	int dev_fd;
 	int rc;
 	uint64_t *add_memory = NULL;
+	struct metadata meta_data;
 
 	/* Get max_mmap_size form the metadata section of IMAGE */
-	max_mmap_size = *(uint64_t *) (bin + PAGE_SIZE);
+	memset(&meta_data, 0, sizeof(struct metadata));
+	meta_data = *(struct metadata *) (bin + PAGE_SIZE);
+
+	printf("metadata info:\n max_mmap_size %ld byte;\nnull_dereference_protection is enabled %d;\nsecs->attributes is %ld\n xfrm is %ld\n", meta_data.max_mmap_size, meta_data.null_dereference_protection, meta_data.attributes, meta_data.xfrm);
 
 	dev_fd = open(sgx_dev_path, O_RDWR);
 	if (dev_fd < 0) {
@@ -310,7 +322,7 @@ static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 	if (!(sigstruct->body.attributes & SGX_ATTR_DEBUG))
 		enclave_debug = false;
 
-	if (!encl_create(dev_fd, bin_size, secs, encl_info, max_mmap_size))
+	if (!encl_create(dev_fd, bin_size, secs, encl_info, &meta_data))
 		goto out_dev_fd;
 
 	uint64_t *ssa_frame = valloc(PAGE_SIZE * secs->ssa_frame_size);
@@ -325,12 +337,12 @@ static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 	tcs->entry_offset += encl_info->encl_offset;
 
 	uint64_t add_size = 0;
-	if (max_mmap_size) {
+	if (meta_data.max_mmap_size) {
 		/* *INDENT-OFF* */
-		add_size = max_mmap_size - PAGE_SIZE * secs->ssa_frame_size -
+		add_size = meta_data.max_mmap_size - PAGE_SIZE * secs->ssa_frame_size -
 			   bin_size;
 		/* *INDENT-ON* */
-		if (max_mmap_size % PAGE_SIZE)
+		if (meta_data.max_mmap_size % PAGE_SIZE)
 			add_size = (add_size / PAGE_SIZE + 1) * PAGE_SIZE;
 		add_memory = valloc(add_size);
 		if (add_memory == NULL) {
@@ -363,7 +375,7 @@ static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 						SGX_REG_PAGE_FLAGS))
 			goto out_add_memory;
 
-		if (max_mmap_size) {
+		if (meta_data.max_mmap_size) {
 			if (!encl_add_pages_with_mrmask(dev_fd,
 							load_base + bin_size +
 							PAGE_SIZE * secs->ssa_frame_size,
@@ -391,7 +403,7 @@ static bool encl_build(struct sgx_secs *secs, void *bin, unsigned long bin_size,
 				    SGX_REG_PAGE_FLAGS))
 			goto out_add_memory;
 
+		if (meta_data.max_mmap_size) {
 			if (!encl_add_pages(dev_fd,
 					    load_base + bin_size +
 					    PAGE_SIZE * secs->ssa_frame_size,
@@ -590,8 +602,7 @@ int encl_init(struct enclave_info *encl_info)
 	}
 
 	bin_size = align_up(bin_size, PAGE_SIZE);
-	if (!encl_build(&secs, bin, bin_size, &sigstruct, &token,
-			encl_info, max_mmap_size))
+	if (!encl_build(&secs, bin, bin_size, &sigstruct, &token, encl_info))
 		return -EINVAL;
 
 	return 0;
diff --git a/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c b/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
index 795e7cf..527f2b5 100644
--- a/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
+++ b/rune/libenclave/internal/runtime/pal/skeleton/sgxsign.c
@@ -238,6 +238,7 @@ static bool mrenclave_eextend(EVP_MD_CTX *ctx, uint64_t offset, uint8_t *data)
  */
 /* *INDENT-OFF* */
 static bool measure_encl(const char *path, uint8_t *mrenclave,
+			 uint64_t attributes,
 			 uint32_t miscselect, uint64_t xfrm,
 			 uint64_t max_mmap_size,
 			 uint64_t mmap_min_addr,
@@ -268,9 +269,9 @@ static bool measure_encl(const char *path, uint8_t *mrenclave,
 		goto out;
 	}
 
-        /*Save certain flags used by sgxsign tool to metadata area,
-	* skeleton runtime will act accordingly.
-	*/
+	/*Save certain flags used by sgxsign tool to metadata area,
+	 * skeleton runtime will act accordingly.
+	 */
 	fseek(file, PAGE_SIZE, SEEK_SET);
 	if (fwrite(&max_mmap_size, 1, sizeof(uint64_t), file) !=
 	    sizeof(uint64_t)) {
@@ -278,8 +279,16 @@ static bool measure_encl(const char *path, uint8_t *mrenclave,
 		EVP_MD_CTX_destroy(ctx);
 		return false;
 	}
+	fwrite(&null_dereference_protection, 1, sizeof(bool), file);
+	fwrite(&attributes, 1, sizeof(uint64_t), file);
+	fwrite(&xfrm, 1, sizeof(uint64_t), file);
 	fseek(file, 0L, SEEK_SET);
 
+	printf("***sgxsign: null_dereference_protection is %d\n",
+	       null_dereference_protection);
+	printf("***sgxsign: attributes is %ld\n", attributes);
+	printf("***sgxsign: xfrm, is %ld\n", xfrm);
+
 	if (!sb.st_size || sb.st_size & 0xfff) {
 		fprintf(stderr, "Invalid blob size %lu\n", sb.st_size);
 		goto out;
@@ -510,16 +519,20 @@ int main(int argc, char **argv)
 	uint64_t header1[2] = { 0x000000E100000006, 0x0000000000010000 };
 	uint64_t header2[2] = { 0x0000006000000101, 0x0000000100000060 };
 	uint64_t xfrm;
+	uint64_t expect_xfrm = 0;
+	uint64_t expect_attr = 0;
 	struct sgx_sigstruct ss;
 	const char *program;
 	int opt;
 	RSA *sign_key;
 	bool enclave_debug = true;
 	uint64_t max_mmap_size = 0;
-	char *const short_options = "ps:";
+	char *const short_options = "ps:x:a:";
 	struct option long_options[] = {
 		{"product", no_argument, NULL, 'p'},
 		{"mmap-size", required_argument, NULL, 's'},
+		{"xfrm", required_argument, NULL, 'x'},
+		{"attr", required_argument, NULL, 'a'},
 		{0, 0, 0, 0}
 	};
 
@@ -535,6 +548,10 @@ int main(int argc, char **argv)
 		case 's':
 			max_mmap_size = atoi(optarg);
 			break;
+		case 'x':
+			expect_xfrm = atoi(optarg);
+		case 'a':
+			expect_attr = atoi(optarg);
 		case -1:
 			break;
 		default:
@@ -563,8 +580,17 @@ int main(int argc, char **argv)
 	if (enclave_debug)
 		ss.body.attributes |= SGX_ATTR_DEBUG;
 
+	if (expect_attr)
+		ss.body.attributes = expect_attr;
+
 	get_sgx_xfrm_by_cpuid(&xfrm);
 	ss.body.xfrm = xfrm;
+	if (expect_xfrm)
+		ss.body.xfrm = expect_xfrm;
+
+	printf("***sgxsign: expect ss.body.xfrm is %ld\n", ss.body.xfrm);
+	printf("***sgxsign: expect ss.body.attributes is %ld\n",
+	       ss.body.attributes);
 
 	ss.body.attributes_mask = ss.body.attributes;
 	ss.body.miscselect = get_sgx_miscselect_by_cpuid();
@@ -580,7 +606,8 @@ int main(int argc, char **argv)
 	BN_bn2bin(get_modulus(sign_key), ss.modulus);
 
 	/* *INDENT-OFF* */
-	if (!measure_encl(argv[1], ss.body.mrenclave, ss.body.miscselect,
+	if (!measure_encl(argv[1], ss.body.mrenclave, ss.body.attributes,
+				ss.body.miscselect,
 			  ss.body.xfrm, max_mmap_size, mmap_min_addr,
 			  !is_oot_kernel_driver()))
 		goto out;
-- 
2.17.1

